<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Astedroids</title>
    <style>
      @font-face {
        font-family: "Harlow Solid";
        src: url("fonts/HARLOWSI.TTF") format("truetype");
      }
      h1 {
        font-size: 4em;
        margin: 0px;
        font-family: "Harlow Solid", sans-serif;
        color: lightgray;
        text-align: center;
      }
      p {
        margin: 2px;
        font-family: Noto Sans, sans-serif;
        color: lightgray;
        text-align: center;
      }
      body {
        margin: 0;
        padding: 0;
        background: #111;
        overflow: hidden;
      }
      canvas {
        display: block;
        margin: 0 auto;
        background: #111;
        border: 10px solid #efefef;
      }
    </style>
  </head>
  <body>
    <h1>Astedroids</h1>
    <p>by Nikolai Myhre</p>
    <canvas id="game" width="800" height="600"></canvas>
    <script>
      let showStartScreen = true;
      const img = new Image();
      img.src = "space.jpg";
      function draw() {
        requestAnimationFrame(draw);
      }
      img.onload = draw;
      const bossMusic = new Audio("kule_lyder.mp3");
      bossMusic.loop = true;

      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      // ==== GAME STATE ====
      const keys = {};
      let canShoot = true;
      let score = 0;
      let lives = 5;
      let level = 1;
      let showLevelScreen = false;
      let levelScreenTimer = 0;
      let spawnTime = Date.now();
      let gameOver = false;
      let bossLevel = 5;
      let boss = null;
      const bossBullets = [];

      const friction = 0.98;
      const rotationSpeed = 0.05;
      const thrustPower = 0.12;
      const laserSound = new Audio("laser-shot-ingame-230500.mp3");
      const thrustSound = new Audio("loopingthrust-95548.mp3");

      const asteroidSizeMap = { large: 50, medium: 30, small: 15 };
      const velocityBySize = { large: 1, medium: 2, small: 3 };
      const points = { large: 50, medium: 70, small: 100 };

      const ship = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 15,
        angle: 0,
        vx: 0,
        vy: 0,
        rotationSpeed: 0,
        thrusting: false,
      };

      const bullets = [];
      const explosions = [];
      const asteroids = [];

      // ==== INPUT HANDLING ====
      window.addEventListener("keydown", (e) => {
        if (showStartScreen) {
          showStartScreen = false;
          return;
        }
        keys[e.key] = true;
        if (e.key === " " && canShoot) {
          shootBullet();
          canShoot = false;
        }
      });

      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
        if (e.key === " ") canShoot = true;
        if (!keys["ArrowLeft"] && !keys["ArrowRight"]) ship.rotationSpeed = 0;
        if (!keys["ArrowUp"]) {
          if (ship.thrusting) {
            clearTimeout(thrustStopTimeout);
            thrustStopTimeout = setTimeout(() => {
              thrustSound.pause();
              thrustSound.currentTime = 0;
              ship.thrusting = false;
            }, 200);
          }
        }
      });

      // ==== GAME FUNCTIONS ====
      function shootBullet() {
        const baseAngle = ship.angle - Math.PI / 2;
        const shot = laserSound.cloneNode();
        shot.volume = 0.2;
        shot.play();

        if (level === 1 || level === 2) {
          bullets.push({
            x: ship.x,
            y: ship.y,
            vx: Math.cos(baseAngle) * 5,
            vy: Math.sin(baseAngle) * 5,
            life: 70,
          });
        } else if (level === 3 || level === 4) {
          const angles = [-0.26, 0.26];
          angles.forEach((offset) => {
            bullets.push({
              x: ship.x,
              y: ship.y,
              vx: Math.cos(baseAngle + offset) * 5,
              vy: Math.sin(baseAngle + offset) * 5,
              life: 80,
            });
          });
        } else if (level === 5 || level === 6) {
          const angles = [-0.26, 0, 0.26];
          angles.forEach((offset) => {
            bullets.push({
              x: ship.x,
              y: ship.y,
              vx: Math.cos(baseAngle + offset) * 5,
              vy: Math.sin(baseAngle + offset) * 5,
              life: 90,
            });
          });
        } else if (level === 7 || level === 8) {
          const angles = [-0.52, -0.26, 0, 0.26, 0.52];
          angles.forEach((offset) => {
            bullets.push({
              x: ship.x,
              y: ship.y,
              vx: Math.cos(baseAngle + offset) * 5,
              vy: Math.sin(baseAngle + offset) * 5,
              life: 100,
            });
          });
        } else if (level >= 9) {
          const angles = [-0.78, -0.52, -0.26, 0, 0.26, 0.52, 0.78];
          angles.forEach((offset) => {
            bullets.push({
              x: ship.x,
              y: ship.y,
              vx: Math.cos(baseAngle + offset) * 5,
              vy: Math.sin(baseAngle + offset) * 5,
              life: 80,
            });
          });
        }
      }

      function bossShoot() {
        if (!boss) return;

        const dx = ship.x - boss.x;
        const dy = ship.y - boss.y;
        let angle = Math.atan2(dy, dx);

        angle += Math.random() * 0.2 - 0.1;

        const speed = 2;
        bossBullets.push({
          x: boss.x,
          y: boss.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: 5,
        });
      }

      function isInvincible() {
        return Date.now() - spawnTime < 2000;
      }

      function spawnAsteroids(count) {
        for (let i = 0; i < count; i++) {
          let x,
            y,
            safe = false;
          while (!safe) {
            x = Math.random() * canvas.width;
            y = Math.random() * canvas.height;
            const dx = x - ship.x;
            const dy = y - ship.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            safe = dist > 100;
          }
          const sizeLabel = "large";
          asteroids.push({
            x,
            y,
            vx: Math.random() * 2 - 1,
            vy: Math.random() * 2 - 1,
            size: asteroidSizeMap[sizeLabel],
            sizeLabel,
            shape: generateRockShape(),
          });
        }
      }

      let bossSpawned = false;

      function nextLevel() {
        level++;

        if (level === bossLevel && !bossSpawned) {
          showLevelScreen = true;
          levelScreenTimer = 120;
          spawnBoss();
          bossSpawned = true;
        } else {
          spawnAsteroids(3 + 2 * (level - 1));
          showLevelScreen = true;
          levelScreenTimer = 120;
        }
      }

      function resetShip() {
        if (level === bossLevel) {
          ship.x = canvas.width / 4;
          ship.y = canvas.height / 4;
          ship.vx = 0;
          ship.vy = 0;
          boss.x = canvas.width / 1.5;
          boss.y = canvas.height / 1.5;
        } else {
          ship.x = canvas.width / 2;
          ship.y = canvas.height / 2;
          ship.vx = 0;
          ship.vy = 0;
          spawnTime = Date.now();
        }
      }

      function generateRockShape() {
        const points = 10 + Math.floor(Math.random() * 5);
        const shape = [];
        for (let i = 0; i < points; i++) {
          const angle = (Math.PI * 2 * i) / points;
          const radiusOffset = 0.6 + Math.random() * 0.5;
          shape.push({ angle, radiusOffset });
        }
        return shape;
      }

      function splitAsteroid(asteroid) {
        const newLabel = { large: "medium", medium: "small" }[
          asteroid.sizeLabel
        ];
        if (!newLabel) return [];

        const count = newLabel === "small" ? 3 : 2;
        const newAsteroids = [];

        for (let i = 0; i < count; i++) {
          newAsteroids.push({
            x: asteroid.x,
            y: asteroid.y,
            vx: Math.random() * 2 - 1,
            vy: Math.random() * 2 - 1,
            size: asteroidSizeMap[newLabel],
            sizeLabel: newLabel,
            shape: generateRockShape(),
          });
        }

        return newAsteroids;
      }

      // ==== UPDATE FUNCTIONS ====
      function updateShip() {
        if (keys["ArrowLeft"]) ship.rotationSpeed = -rotationSpeed;
        else if (keys["ArrowRight"]) ship.rotationSpeed = rotationSpeed;
        else ship.rotationSpeed = 0;

        if (keys["ArrowUp"]) {
          if (!ship.thrusting) {
            thrustSound.currentTime = 0;
            thrustSound.play();
            thrustSound.volume = 0.5;
            ship.thrusting = true;
          }
          ship.vx += Math.cos(ship.angle - Math.PI / 2) * thrustPower;
          ship.vy += Math.sin(ship.angle - Math.PI / 2) * thrustPower;
        } else {
          if (ship.thrusting) {
            thrustSound.pause();
            ship.thrusting = false;
          }
        }

        ship.angle += ship.rotationSpeed;

        ship.vx *= friction;
        ship.vy *= friction;
        ship.x += ship.vx;
        ship.y += ship.vy;

        // Border confinement
        ship.x = Math.max(
          ship.radius,
          Math.min(canvas.width - ship.radius, ship.x)
        );
        ship.y = Math.max(
          ship.radius,
          Math.min(canvas.height - ship.radius, ship.y)
        );
      }

      function updateBullets() {
        bullets.forEach((b) => {
          b.x += b.vx;
          b.y += b.vy;
          b.life--;
        });

        for (let i = bullets.length - 1; i >= 0; i--) {
          if (bullets[i].life <= 0) bullets.splice(i, 1);
        }
      }

      function updateBossBullets() {
        for (let i = bossBullets.length - 1; i >= 0; i--) {
          const b = bossBullets[i];
          b.x += b.vx;
          b.y += b.vy;

          if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bossBullets.splice(i, 1);
          }
        }
      }

      function updateAsteroids() {
        asteroids.forEach((a) => {
          a.x += a.vx;
          a.y += a.vy;

          if (a.x > canvas.width + a.size) a.x = -a.size;
          else if (a.x < -a.size) a.x = canvas.width + a.size;
          if (a.y > canvas.height + a.size) a.y = -a.size;
          else if (a.y < -a.size) a.y = canvas.height + a.size;
        });
      }

      function handleCollisions() {
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const a = asteroids[i];
          const dx = ship.x - a.x;
          const dy = ship.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (boss) {
            const dxBoss = ship.x - boss.x;
            const dyBoss = ship.y - boss.y;

            if (
              Math.abs(dxBoss) < boss.radiusX + ship.radius &&
              Math.abs(dyBoss) < boss.radiusY + ship.radius
            ) {
              if (!isInvincible()) {
                lives--;
                if (lives < 0) {
                  gameOver = true;
                  bossMusic.pause();
                  const retry = confirm(
                    "Game Over! Your score: " + score + "\nTry again?"
                  );
                  if (retry) location.reload();
                  return;
                } else {
                  resetShip();
                }
              }
            }

            for (let j = bullets.length - 1; j >= 0; j--) {
              const b = bullets[j];
              const dxB = b.x - boss.x;
              const dyB = b.y - boss.y;

              const normX = dxB / boss.radiusX;
              const normY = dyB / boss.radiusY;
              if (normX * normX + normY * normY <= 1) {
                boss.hp--;
                bullets.splice(j, 1);

                if (boss && boss.hp <= 0) {
                  score += 5000;
                  boss = null;
                  bossBullets.length = 0;
                  bossMusic.pause();
                  alert("Boss defeated! You win!");
                }
              }
            }

            for (let i = bossBullets.length - 1; i >= 0; i--) {
              const b = bossBullets[i];
              const dxB = b.x - ship.x;
              const dyB = b.y - ship.y;
              const dist = Math.sqrt(dxB * dxB + dyB * dyB);
              if (dist < b.radius + ship.radius) {
                if (!isInvincible()) {
                  lives--;
                  bossBullets.splice(i, 1);
                  if (lives < 0) {
                    gameOver = true;
                    bossMusic.pause();
                    const retry = confirm(
                      "Game Over! Your score: " + score + "\nTry again?"
                    );
                    if (retry) location.reload();
                    return;
                  } else {
                    resetShip();
                  }
                }
              }
            }
          }

          if (!isInvincible() && dist < ship.radius + a.size) {
            lives--;
            if (lives < 0) {
              gameOver = true;
              const retry = confirm(
                "Game Over! Your score: " + score + "\nTry again?"
              );
              if (retry) location.reload();
              return;
            } else resetShip();
          }

          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < a.size) {
              score += points[a.sizeLabel];
              bullets.splice(j, 1);
              explosions.push({ x: b.x, y: b.y, radius: 0, max: 10 });
              asteroids.splice(i, 1);
              asteroids.push(...splitAsteroid(a));
              break;
            }
          }
        }
      }

      function updateExplosions() {
        explosions.forEach((e) => {
          e.radius += 1;
        });
        for (let i = explosions.length - 1; i >= 0; i--) {
          if (explosions[i].radius > explosions[i].max) {
            explosions.splice(i, 1);
          }
        }
      }

      function updateBoss() {
        if (!boss) return;

        boss.x += boss.vx;
        boss.y += boss.vy;

        if (boss.x > canvas.width - boss.radiusX || boss.x < canvas.width / 2)
          boss.vx *= -1;
        if (boss.y > canvas.height / 2 || boss.y < 50) boss.vy *= -1;

        boss.shootCooldown--;
        if (boss.shootCooldown <= 0) {
          bossShoot();
          boss.shootCooldown = 90;
        }
      }

      // ==== DRAW FUNCTIONS ====
      function drawShip() {
        if (isInvincible() && Math.floor(Date.now() / 200) % 2 === 0) return;

        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        ctx.fillStyle = "#fefefe";

        if (ship.thrusting) {
          ctx.beginPath();
          ctx.fillStyle = "white";
          ctx.moveTo(-4, 24);
          ctx.lineTo(0, 32 + Math.random() * 5);
          ctx.lineTo(4, 24);
          ctx.closePath();
          ctx.fill();
        }

        ctx.beginPath();
        ctx.fillStyle = "#fefefe";
        ctx.moveTo(0, -28);
        ctx.lineTo(-5, -10);
        ctx.lineTo(5, -10);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.rect(-5, -10, 10, 36);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(-5, 0);
        ctx.lineTo(-12, 18);
        ctx.lineTo(-5, 18);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(12, 18);
        ctx.lineTo(5, 18);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = "gray";
        ctx.rect(-5, 22, 10, 4);
        ctx.fill();

        ctx.restore();
      }

      function drawAsteroid(a) {
        ctx.save();
        ctx.translate(a.x, a.y);
        ctx.fillStyle = "gray";
        ctx.lineWidth = 2;
        ctx.beginPath();
        a.shape.forEach((point, i) => {
          const r = a.size * point.radiusOffset;
          const x = Math.cos(point.angle) * r;
          const y = Math.sin(point.angle) * r;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawBullets() {
        ctx.fillStyle = "lightgray";
        bullets.forEach((b) => {
          ctx.beginPath();
          ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawBossBullets() {
        ctx.fillStyle = "white";
        bossBullets.forEach((b) => {
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawExplosions() {
        explosions.forEach((e) => {
          ctx.beginPath();
          ctx.fillStyle = "white";
          ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawScore() {
        ctx.fillStyle = "lightgray";
        ctx.font = "20px Arial";
        ctx.textAlign = "left";
        ctx.fillText(`Lives: ${lives}`, 20, 30);
        ctx.textAlign = "center";
        ctx.fillText(`Level: ${level}`, canvas.width / 2, 30);
        ctx.textAlign = "right";
        ctx.fillText(`Score: ${score}`, canvas.width - 20, 30);
      }

      function clear() {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      }

      function spawnBoss() {
        boss = {
          x: canvas.width - 150,
          y: 150,
          radiusX: 60,
          radiusY: 40,
          hp: 100,
          vx: 1.5,
          vy: 1,
          shootCooldown: 0,
        };
        bossMusic.play();
      }

      function drawBoss() {
        if (!boss) return;

        ctx.save();
        ctx.translate(boss.x, boss.y);
        ctx.fillStyle = "white";

        // Draw oval body
        ctx.beginPath();
        ctx.ellipse(0, 0, boss.radiusX, boss.radiusY, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Draw 4 tentacles
        for (let i = 0; i < 4; i++) {
          const angle = (Math.PI / 2) * i;
          const x = Math.cos(angle) * boss.radiusX;
          const y = Math.sin(angle) * boss.radiusY;
          ctx.beginPath();
          ctx.ellipse(x, y, 15, 5, angle, 0, 2 * Math.PI);
          ctx.fill();
        }

        ctx.restore();
      }

      function drawBossHP() {
        if (!boss) return;
        ctx.fillStyle = "lightgray";
        ctx.font = "18px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
          `Boss HP: ${boss.hp}`,
          canvas.width / 2,
          canvas.height - 20
        );
      }

      // ==== MAIN LOOP ====
      function gameLoop() {
        if (gameOver) return;
        clear();

        if (showStartScreen) {
          ctx.fillStyle = "#111";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "lightgray";
          ctx.font = '40px "Harlow Solid", sans-serif';
          ctx.textAlign = "center";
          ctx.fillText(
            "Press any key to start",
            canvas.width / 2,
            canvas.height / 2
          );
          requestAnimationFrame(gameLoop);
          return;
        }
        if (showLevelScreen) {
          ctx.fillStyle = "#111";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "lightgray";
          ctx.font = '40px "Harlow Solid", sans-serif';
          ctx.textAlign = "center";
          ctx.fillText(
            `Level ${level} - Are you ready?`,
            canvas.width / 2,
            canvas.height / 2
          );
          levelScreenTimer--;
          if (levelScreenTimer <= 0) {
            showLevelScreen = false;
            spawnAsteroids(3 + 2 * (level - 1));
          }
          requestAnimationFrame(gameLoop);
          return;
        }
        updateShip();
        updateBullets();
        updateAsteroids();
        handleCollisions();
        updateExplosions();

        drawScore();
        drawShip();
        drawBullets();
        drawExplosions();
        asteroids.forEach(drawAsteroid);
        updateBoss();
        updateBossBullets();

        drawBoss();
        drawBossBullets();
        drawBossHP();

        if (asteroids.length === 0) nextLevel();

        requestAnimationFrame(gameLoop);
      }

      spawnAsteroids(4);
      if (level === bossLevel) spawnBoss();
      gameLoop();
    </script>
  </body>
</html>
